open! StdLabels
open! MoreLabels

module Parser = struct
  type token =
    | DIG_0_9 of string
    | RAKE_DENT
    | COMMA
    | HYPHEN
    | LINE_BREAK

  open Parsing

  let _ = parse_error

  let yytransl_const =
    [| 258 (* RAKE_DENT *); 259 (* COMMA *); 260 (* HYPHEN *); 261 (* LINE_BREAK *); 0 |]
  ;;

  let yytransl_block = [| 257 (* DIG_0_9 *); 0 |]

  let yylhs =
    "\255\255\001\000\002\000\002\000\003\000\003\000\004\000\005\000\006\000\006\000\007\000\008\000\008\000\000\000"
  ;;

  let yylen =
    "\002\000\001\000\002\000\002\000\001\000\002\000\001\000\003\000\001\000\002\000\001\000\001\000\002\000\002\000"
  ;;

  let yydefred =
    "\000\000\000\000\000\000\000\000\000\000\013\000\001\000\000\000\000\000\000\000\006\000\000\000\010\000\012\000\009\000\002\000\003\000\005\000\000\000\007\000"
  ;;

  let yydgoto = "\002\000\005\000\006\000\007\000\008\000\009\000\010\000\011\000\012\000"

  let yysindex =
    "\002\000\000\255\000\000\003\255\004\255\000\000\000\000\002\255\005\255\004\255\000\000\006\255\000\000\000\000\000\000\000\000\000\000\000\000\007\255\000\000"
  ;;

  let yyrindex =
    "\000\000\000\000\000\000\009\255\008\255\000\000\000\000\000\000\000\000\010\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
  ;;

  let yygindex =
    "\000\000\000\000\000\000\000\000\000\000\000\000\252\255\000\000\005\000"
  ;;

  let yytablesize = 15

  let yytable =
    "\014\000\003\000\004\000\001\000\003\000\017\000\004\000\015\000\013\000\018\000\016\000\019\000\011\000\008\000\000\000\004\000"
  ;;

  let yycheck =
    "\004\000\001\001\002\001\001\000\001\001\009\000\002\001\005\001\003\000\003\001\005\001\004\001\003\001\005\001\255\255\005\001"
  ;;

  let yynames_const = "RAKE_DENT\000COMMA\000HYPHEN\000LINE_BREAK\000"
  let yynames_block = "DIG_0_9\000"

  let yyact =
    [| (fun _ -> failwith "parser")
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 0 : 'line) in
         Obj.repr (_1 : int))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 1 : 'priced_line) in
         Obj.repr (_1 : 'line))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 1 : 'rake_line) in
         Obj.repr (_1 : 'line))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 0 : 'price_spec) in
         Obj.repr (_1 : 'priced_line))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 1 : 'price_spec) in
         let _2 = (Parsing.peek_val __caml_parser_env 0 : 'rake) in
         Obj.repr (_1 * _2 : 'priced_line))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rake) in
         Obj.repr (_1 * 42 : 'rake_line))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pub_integer) in
         Obj.repr (_1 : 'price_spec))
     ; (fun __caml_parser_env -> Obj.repr (1 : 'rake))
     ; (fun __caml_parser_env ->
         let _2 = (Parsing.peek_val __caml_parser_env 0 : 'rake) in
         Obj.repr (1 + _2 : 'rake))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 0 : 'dig_seq) in
         Obj.repr (int_of_string _1 : 'pub_integer))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
         Obj.repr (_1 : 'dig_seq))
     ; (fun __caml_parser_env ->
         let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
         let _2 = (Parsing.peek_val __caml_parser_env 0 : 'dig_seq) in
         Obj.repr (_1 ^ _2 : 'dig_seq))
       (* Entry bill *)
     ; (fun __caml_parser_env ->
         raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
    |]
  ;;

  let yytables =
    { Parsing.actions = yyact
    ; Parsing.transl_const = yytransl_const
    ; Parsing.transl_block = yytransl_block
    ; Parsing.lhs = yylhs
    ; Parsing.len = yylen
    ; Parsing.defred = yydefred
    ; Parsing.dgoto = yydgoto
    ; Parsing.sindex = yysindex
    ; Parsing.rindex = yyrindex
    ; Parsing.gindex = yygindex
    ; Parsing.tablesize = yytablesize
    ; Parsing.table = yytable
    ; Parsing.check = yycheck
    ; Parsing.error_function = parse_error
    ; Parsing.names_const = yynames_const
    ; Parsing.names_block = yynames_block
    }
  ;;

  let bill (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) : int =
    Parsing.yyparse yytables 1 lexfun lexbuf
  ;;
end

module Lexer = struct
  open Parser

  let __ocaml_lex_tables =
    { Lexing.lex_base = "\000\000\251\255\252\255\253\255\254\255\255\255"
    ; Lexing.lex_backtrk = "\255\255\255\255\255\255\255\255\255\255\255\255"
    ; Lexing.lex_default = "\255\255\000\000\000\000\000\000\000\000\000\000"
    ; Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\000\000\000\000\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
    ; Lexing.lex_check =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\255\255\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255"
    ; Lexing.lex_base_code = ""
    ; Lexing.lex_backtrk_code = ""
    ; Lexing.lex_default_code = ""
    ; Lexing.lex_trans_code = ""
    ; Lexing.lex_check_code = ""
    ; Lexing.lex_code = ""
    }
  ;;

  let rec token lexbuf = __ocaml_lex_token_rec lexbuf 0

  and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
    match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
    | 0 -> LINE_BREAK
    | 1 -> HYPHEN
    | 2 -> COMMA
    | 3 -> RAKE_DENT
    | 4 -> DIG_0_9 (Lexing.lexeme lexbuf)
    | __ocaml_lex_state ->
      lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_token_rec lexbuf __ocaml_lex_state
  ;;
end

let round_to_ten num =
  (* Printf.printf "Rounding %d to nearest ten\n" num; *)
  let num = num + 9 in
  num - (num mod 10)
;;

let () =
  let rec loop acc =
    match input_line stdin with
    | line ->
      let lexbuf = Lexing.from_string (line ^ "\n") in
      let bill = Parser.bill Lexer.token lexbuf in
      (* Printf.printf "Line: %s, Bill: %d\n" line bill; *)
      loop (acc + bill)
    | exception End_of_file -> round_to_ten acc
  in
  loop 0 |> Format.printf "%d,-\n"
;;
